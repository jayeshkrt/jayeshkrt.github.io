[ { "title": "Perform DFS on Adjacency List and Return List as result in Python", "url": "/posts/bfs-adjacency-list-python-return-list/", "categories": "graph", "tags": "BFS, graph, python, SdeSheetChallenge", "date": "2022-09-19 00:00:00 +0530", "snippet": "How to Perform BFS (Breadth First Search) on a given Ajacency List and return a List in Python?You will be given an adjacency list (list of lists), and will be reuired to perform BFS on all the nodes and store the results of BFS in a list and return it.Here is the code to do the sameNote: The code also lists how to take input of graph in python, just in case you need it in an interview# store result of BFS in a list# refer: https://practice.geeksforgeeks.org/problems/bfs-traversal-of-graph/1class Solution:\tdef __init__(self):\t\tself.result = []\tdef dfs(self, adj, startNode):\t\t# create an empty queue to store\t\t# the child whose further children will be visited\t\tqueue = []\t\t# this list keeps track if we have visited the node or not\t\tvisited = []\t\t# add the starting node to both visited and queue\t\tqueue.append(startNode)\t\tvisited.append(startNode)\t\t# now we will keep adding the children in the queue\t\t# and keep visiting and adding the children until\t\t# all the children nodes are exhausted\t\twhile queue:\t\t\t# remove the first element of queue\t\t\tcurrentNode = queue.pop(0)\t\t\t# as dfs has been performed on it just now\t\t\t# we add it to the result\t\t\tself.result.append(currentNode)\t\t\t# loop the same above step to all the children of current node\t\t\tfor child in adj[currentNode]:\t\t\t\tif child not in visited:\t\t\t\t\tvisited.append(child)\t\t\t\t\tqueue.append(child)\tdef bfsOfGraph(self, V, adj):\t\t# code here\t\t# call the function that does dfs with starting node (i.e. 0)\t\tself.dfs(adj, 0)\t\t# return the list stored\t\treturn self.resultdef main():\t# take input from the user\t# take vertices and no_of edges as input\tV, E = map(int, input().split())\t# create an empty adjacent list \tadj = []\t# add empty list for each vertex\tfor i in range(V+1):\t\ttemp = []\t\tadj.append(temp)\t# now the consecutive lines contain the edges, so take input of that\tfor i in range(E):\t\tfirst, second = map(int, input().split())\t\t# store the entries in the adjacency list\t\tadj[first].append(second)\t\tadj[second].append(first)\t\t# create an object of Solution class\tsol = Solution()\t# call the bfsOfGraph funtion\tprint(sol.bfsOfGraph(V, adj))if __name__ == '__main__':\tmain()" }, { "title": "Return result as a List after Performing DFS (Depth First Search) in Python", "url": "/posts/dfs-python-return-list/", "categories": "graph", "tags": "graph, DFS, input/output, SdeSheetChallenge", "date": "2022-09-17 17:36:00 +0530", "snippet": "How to store the result of DFS (Depth First Search) in a List in PythonIn coding probs on websites, you are given an adjacency list and number of vertices as input. You are required to perform DFS (Depth First Search), and store the vertices visited in a list and return backHere’s the code to do the same:# given an adjacency list, perform dfs and store the output in a list and return it# Refer : https://practice.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1class Solution:\tdef __init__(self):\t\t# a variable that can be accessed by every function in the class\t\tself.result = []\t# helper function that performs actual DFS by visiting every node of \t# the graph and adds the current node to the list named \"result\"\tdef dfs(self, adj, node):\t\t# add the current node the result\t\tself.result.append(node)\t\t# visit every child node and perform dfs on it\t\tfor child in adj[node]:\t\t\t# do the DFS only if it is not already visited and counted in the result\t\t\tif child not in self.result:\t\t\t\tself.dfs(adj,child)\t# THIS FUNCTION IS GIVEN ON STARTER TEMPLATE IN THE PROBLEM\tdef dfsOfGraph(self, V, adj):\t\t# your code goes here\t\t# V is number of vertices\t\t# adj is adjacency list\t\t# we start with the first node which is 0. \t\t# That's why 0 is used as input node below. \t\t# The DFS will be perfomed on further nodes successively\t\tself.dfs(adj, 0)\t\t# after the DFS is done, return the visited nodes stored in the result\t\treturn self.resultNote that, in the above code, we took advantage of the class Solution. We added an __init__(self) method. This helped us declare a sort of global variable that can be accessed by any function in the class." }, { "title": "Take Input of Graph in Python", "url": "/posts/take-input-of-graph-python/", "categories": "graph", "tags": "input, graph, competitive_programming, CP, python, beginner", "date": "2022-09-17 17:10:00 +0530", "snippet": "How to take an input of Graph in Python for Competitve Programming (CP) problems?The first line generally contains number of vertices V and the next E lines denotes the Edges between the vertices.So, the input in coding problems on websites looks like thisInput: V En1 n2 |n2 n3 |n3 n4 | E lines (edges)n1 n5 |n4 n2 |Here’s how to take the input and store in an adjacency list in Python:# take inputs V and EV,E = map(int, input().split())# create an empty adjacent listadj = []# there are V vertices so create empty lists in \"adj\" to store the neighboursfor i in range(V+1):\ttemp = []\tadj.append(temp)# following E lines take input and update the adjacency listfor j in range(E):\t# store the 2 integers as m and n\tm,n = map(int, input().split())\t# since it is undirected graph, both will be one another's neighbours\tadj[m].append(n)\tadj[n].append(m)# print the list to check if the list is properly createdprint(adj)Example:Input:5 40 20 30 1 2 4Output:[[2,3,1], [0], [0,4], [0], [2], []]" }, { "title": "Getting Started", "url": "/posts/first-post/", "categories": "meta", "tags": "meta, discussion", "date": "2022-09-15 00:00:00 +0530", "snippet": "How to Use The 2 Minute Codes?The only 3 steps to use the website: Just go to the YouTube channel of The 2 Minute Codes, watch the short videos. Read the solution from this website. Copy it down to your textbook and keep revising it at apt intervals. " } ]
